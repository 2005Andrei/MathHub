---
title: "Multi-selection"
description: ""
publishedAt: ""
---

Early in my career, I discovered a trick that has made me immensely productive when writing code. The trick does not involve learning Vim, and it does not involve any magic plugin.

I've used this trick with Sublime Text, Atom, and now VSCode. The trick is basic enough that every text editor I've used supports it out of the box.

The trick is broadly applicable. I use it with multiple programming languages, and I've used it when performing non-programming text editing tasks such as formatting, filtering, or selecting data.

This trick is great for productivity. It also makes writing code just _that_ much more enjoyable. I don't believe I would enjoy my day-to-day as much without it.

So what's the trick?

## Starting with the problem

When editing text, especially structured text, the need occurs to make repeated changes in multiple locations. A common case is renaming a variable.

```javascript
const element = document.querySelect("#container");

if (element && element.hasAttribute("data-active")) {
  element.classList.add("active");
}
// @script slow-rename
```

<CodeScript id="slow-rename" script={[
  { command: "Select Word", word: "element", line: 1 },
  { command: "Type", text: "container" },
  { command: "Select Word", word: "element", line: 3 },
  { command: "Type", text: "container" },
  { command: "Select Word", word: "element", line: 3 },
  { command: "Type", text: "container" },
  { command: "Select Word", word: "element", line: 4 },
  { command: "Type", text: "container" },
]} />

Select and type, select and type.

For a small block of code it's fine. A bit tedious, but fine. Banging this out doesn't take a lot of time.

However, the number of keystrokes grows linearly. Increase the number of references to a few dozens and the task has suddenly become quite taxing.

We want to the effort, currently growing linearly, to grow in a non-linear fashion instead. We can do that using `Command D`.

```javascript
const element = document.querySelect("#container");

if (element && element.hasAttribute("data-active")) {
  element.classList.add("active");
}
// @script fast-rename
```

<CodeScript id="fast-rename" script={[
  { command: "Select Word", word: "element", line: 1 },
  { command: "Command D", times: 3, msBetween: 300 },
  { command: "Type", text: "container" },
]} />

`Command D` selects the next instance of whatever you have selected, which enables multi-cursor editing.

Combined with smart text navigation techniques, we can take `Command D` very far.

<SmallNote>The right way to rename a variable would be to use Rename Symbol, but renaming a variable is a simple example that demonstrates `Command D` well.</SmallNote>


## Navigating text

Before we get into `Command D`, let's take a quick look at text navigation.

First off, the basics:

 * __Arrow keys__ to move the cursor
 * __Shift__ to select text while moving the cursor.

```
// @script arrow-keys loop
The quick brown fox jumps over the lazy dog
```

<CodeScript id="arrow-keys" script={[
  { command: "Select", line: 1, col: 1 },
  { command: "Right", times: 4, msBetween: 140, msAfter: 700 },
  { command: "Shift Right", times: 5, msBetween: 140, msAfter: 700 },
  { command: "Left", times: 5, msBetween: 140 },
]} />

Use `Option` to jump over words.

```
// @script jump-over-words loop
The quick brown fox jumps over the lazy dog
```

<CodeScript id="jump-over-words" script={[
  { command: "Select", line: 1, col: 1 },
  { command: "Option Right", times: 3, msBetween: 300, msAfter: 300 },
  { command: "Right", msAfter: 700 },
  { command: "Shift Option Right", times: 2, msBetween: 300 },
  { command: "Option Left", times: 5, msBetween: 300 },
]} />

Jumping over words allows us to navigate text containing words of different lengths.

```javascript
// @script jump-over-words-demonstration
const items = [
  { show: types.indexOf("added") !== -1 },
  { show: types.indexOf("started") !== -1 },
  { show: types.indexOf("completed") !== -1 },
]
```

<CodeScript id="jump-over-words-demonstration" script={[
  { command: "Select Word", line: 2, word: "indexOf" },
  { command: "Command D", times: 2 },
  { command: "Type", text: "includes" },
  { command: "Option Right", times: 3 },
  { command: "Shift Option Right", times: 2 },
  { command: "Backspace" },
]} />

Use `Command` to jump to the beginning or end of a line.

```
// @script jump-to-end-start-of-line loop
The quick brown fox jumps over the lazy dog
```

<CodeScript id="jump-to-end-start-of-line" script={[
  { command: "Select", line: 1, col: 1 },
  { command: "Shift Command Right", msAfter: 1000 },
  { command: "Right" },
  { command: "Command Left" },
]} />

`Command` allows us to navigate text that contains a variable number of words.

```javascript
// @script jump-to-end-start-of-line-demonstration loop
const items = [
  { id: 1, content: ["foo", "bar"] },
  { id: 2, content: [] },
  { id: 3, content: ["baz"] },
]
```

<CodeScript id="jump-to-end-start-of-line-demonstration" script={[
  { command: "Select Word", line: 2, word: "content" },
  { command: "Command D", times: 2 },
  { command: "Right", times: 3 },
  { command: "Type", text: "new Set(" },
  { command: "Command Right" },
  { command: "Left", times: 3 },
  { command: "Type", text: ")" },
]} />

With text navigation locked down, let's do some cool stuff.


## Finding the pattern

Making effective use of `Command D` comes down to finding patterns in the edits you intend to make.

Take this example of converting a list of markdown bullets to a list of checkboxes.

```txt
// @script markdown-bullets-to-checkboxes
- Task 1
- Task 2
  - Subtask A
  - Subtask B
  - Subtask C
    - Subtask D
- Task 3
  - Another subtask
```

<CodeScript id="markdown-bullets-to-checkboxes" script={[
  { command: "Shift Right" },
  { command: "Command D", times: 7 },
  { command: "Right" },
  { command: "Type", text: " [ ]" },
  { command: "Command Up" },
]} />

In this case, matching the dashes `-` is somewhat obvious.

Here's a slightly more complicated example where we convert a series of `if` statements to a switch statement.


```javascript
// @script turn-ifs-into-switch expectedLines=13
if (element.type === "property") {
  return formatProperty(element);
}

if (element.type === "modifier") {
  return formatModifier(element);
}

if (element.type === "group") {
  return formatGroup(element);
}
```

<CodeScript id="turn-ifs-into-switch" script={[
  { command: "Select Word", word: "element.type", line: 1 },
  { command: "Copy" },
  { command: "Shift Command Enter" },
  { command: "Type", text: "switch (" },
  { command: "Paste" },
  { command: "Type", text: ") {", msAfter: 200 },
  { command: "Down", msAfter: 150 },
  { command: "Command Left" },
  { command: "Shift Command Down" },
  { command: "Tab" },
  { command: "Right" },
  { command: "Type", text: "\n}" },
  { command: "Select Word", word: "if (", line: 2 },
  { command: "Command D", times: 2, msBetween: 350 },
  { command: "Type", text: "case " },
  { command: "Shift Option Right", times: 3 },
  { command: "Shift Right" },
  { command: "Backspace" },
  { command: "Command Right" },
  { command: "Shift Left", times: 3 },
  { command: "Backspace" },
  { command: "Type", text: ":" },
  { command: "Down", times: 2 },
  { command: "Shift Up" },
  { command: "Shift Command Right" },
  { command: "Backspace" },
]} />

Sometimes, the pattern to match is not as obvious.


### Finding non-obvious patterns

Let's say that we're developing a library for evaluating math expressions.

We have a test utility function that looks like so:

```tsx
function expectEqual(expression: string, expectedValue: any): void;
```

It's currently being used to test some behaviors of the library.

```tsx
expectEqual("2**4", 16);
expectEqual("1/0", E_DIV_ZERO);
expectEqual("[1, 3] * 2", [2, 6]);
expectEqual("1/10 < 0.2 ? 'a' : 'b'", "a");
```

However, we want to convert this to something like so:

```tsx
const tests = [
  { expression: "2**4", value: 16 },
  { expression: "1/0", value: E_DIV_ZERO },
  { expression: "[1, 3] * 2", value: [2, 6] },
  { expression: "1/10 < 0.2 ? 'a' : 'b'", value: "a" },
];
```

But what do we match? If we match `expectEqual` and move in from there, we run into the problem of the formulas being of different lengths.

```javascript
// @script match-expect-equal
expectEqual("2**4", 16);
expectEqual("1/0", E_DIV_ZERO);
expectEqual("[1, 3, 5] * 2", [2, 6, 10]);
expectEqual("1/10 < 0.2 ? 'a' : 'b'", "a");
```

<CodeScript id="match-expect-equal" script={[
  { command: "Select Word", word: "expectEqual", line: 1 },
  { command: "Command D", times: 3 },
  { command: "Right", times: 2 },
  { command: "Shift Option Right", times: 4 },
]} />

Matching the end runs into the same problem. The values are of different lengths.

```javascript
// @script match-end
expectEqual("2**4", 16);
expectEqual("1/0", E_DIV_ZERO);
expectEqual("[1, 3, 5] * 2", [2, 6, 10]);
expectEqual("1/10 < 0.2 ? 'a' : 'b'", "a");
```

<CodeScript id="match-end" script={[
  { command: "Select Word", word: ");", line: 1 },
  { command: "Command D", times: 3 },
  { command: "Left" },
  { command: "Shift Option Left" },
]} />

If we try to match the commas `,` between the expression and the value, we also match commas within the expressions and expected values:

```javascript
// @script match-comma
expectEqual("2**4", 16);
expectEqual("1/0", E_DIV_ZERO);
expectEqual("[1, 3, 5] * 2", [2, 6, 10]);
expectEqual("1/10 < 0.2 ? 'a' : 'b'", "a");
```

<CodeScript id="match-comma" script={[
  { command: "Select Word", word: ",", line: 1 },
  { command: "Command D", times: 7 },
]} />

Sometimes, there truly is no pattern to match. but that is rarely the case.

There is __almost always__ some pattern that we can leverage as an anchor for matching.

In this case, we can observe that the expression is always a string followed by some arbitrary second argument. The expression can be of any length, so matching its start is of no use.

But wait! The expression always ends with double quote `"`, immediately followed by a comma `,`.

That's a pattern we can match!

```javascript
// @script match-quote-and-comma expectedLines=6
expectEqual("2**4", 16);
expectEqual("1/0", E_DIV_ZERO);
expectEqual("[1, 3, 5] * 2", [2, 6, 10]);
expectEqual("1/10 < 0.2 ? 'a' : 'b'", "a");
```

<CodeScript id="match-quote-and-comma" script={[
  { command: "Select Word", word: "\",", line: 1 },
  { command: "Command D", times: 3 },
  { command: "Right" },
  { command: "Type", text: " value:" },
  { command: "Command Right" },
  { command: "Backspace", times: 2 },
  { command: "Type", text: " }," },
  { command: "Command Left" },
  { command: "Shift Option Right" },
  { command: "Shift Right" },
  { command: "Type", text: "{ expression: " },
  { command: "Command Up" },
  { command: "Shift Command Enter" },
  { command: "Type", text: "[" },
  { command: "Command Down" },
  { command: "Command Enter" },
  { command: "Type", text: "];" },
  { command: "Up" },
  { command: "Shift Up", times: 3 },
  { command: "Tab" },
  { command: "Command Up" },
  { command: "Type", text: "const tests = " },
]} />


## Extract properties to variables

I sometimes find myself having to extract some properties into variables.

```javascript
// @script extract-properties-to-variables expectedLines=11
setTheme({
  text: "#b9dbfa",
  background: "#090d13",
  medium: "#293946",
  blue: "#399ef4",
});
```

<CodeScript id="extract-properties-to-variables" script={[
  { command: "Select Word", line: 2, word: "  " },
  { command: "Command D", times: 3 },
  { command: "Right" },
  { command: "Shift Command Right" },
  { command: "Copy" },
  { command: "Right" },
  { command: "Shift Option Left", times: 3 },
  { command: "Shift Left", times: 2 },
  { command: "Backspace" },
  { command: "Type", text: "," },
  { command: "Command Up" },
  { command: "Shift Command Enter", times: 2 },
  { command: "Paste" },
  { command: "Select Word", line: 1, word: ": " },
  { command: "Command D", times: 3 },
  { command: "Backspace" },
  { command: "Type", text: " = " },
  { command: "Command Left" },
  { command: "Type", text: "const " },
  { command: "Command Right" },
  { command: "Backspace" },
  { command: "Type", text: ";" },
]} />


## Copy variable names to paste

```javascript
// @script copy-variable-names-into-object expectedLines=11
const text = "#b9dbfa";
const background = "#090d13";
const medium = "#293946";
const blue = "#399ef4";
```

<CodeScript id="copy-variable-names-into-object" script={[
  { command: "Command Down" },
  { command: "Type", text: "\n", times: 2 },
  { command: "Type", text: `setTheme({});` },
  { command: "Select Word", line: 1, word: "const" },
  { command: "Command D", times: 3 },
  { command: "Right", times: 2 },
  { command: "Shift Option Right" },
  { command: "Copy" },
  { command: "Command Down" },
  { command: "Left", times: 3 },
  { command: "Enter", indent: 1 },
  { command: "Paste" },
  { command: "Shift Up", times: 2 },
  { command: "Tab" },
  { command: "Up" },
  { command: "Command Left" },
  { command: "Shift Command Left" },
  { command: "Command D", times: 3 },
  { command: "Command Right" },
  { command: "Type", text: "," },
]} />


## Converting snake-case to camelCase

You may need to convert some HTML into React code, which requires snake-case attributes to be converted to camelCase. We can combine `Command D` with the `Transform to Uppercase` command.

```javascript
// @script snake-case-to-camelcase expectedLines=13
function getAttributes(el) {
}

<div
  data-active="false"
  data-x="0"
  data-y="0"
  data-has-modified="false"
/>
```

<CodeScript id="snake-case-to-camelcase" script={[
  { command: "Select Word", line: 5, word: "=\"" },
  { command: "Command D", times: 3 },
  { command: "Left" },
  { command: "Shift Command Left" },
  { command: "Copy" },
  { command: "Command Up" },
  { command: "Command Enter" },
  { command: "Paste" },
  { command: "Shift Up", times: 2 },
  { command: "Tab" },
  { command: "Left", times: 3 },
  { command: "Up" },
  { command: "Shift Right" },
  { command: "Command D", times: 4 },
  { command: "Backspace" },
  { command: "Shift Right" },
  { command: "Exec", label: "Transform to Uppercase", trigger: "editor.action.transformToUppercase" },
  { command: "Command Left" },
  { command: "Type", text: "const " },
  { command: "Command Right" },
  { command: "Type", text: " = el.getAttribute(\"\");" },
  { command: "Left", times: 3 },
  { command: "Paste" },
]} />


## Format data

So far we've just been dealing with selection. Before we move onto the next example, let's transform the list of users into email strings.

```javascript
// @script convert-users-to-email-string
[
  { "name": "Bill Mason", "email": "bill@domain.co.uk" },
  { "name": "Janet Rose Hills", "email": "janet@example.com" },
  { "name": "Gregory D'Andre", "email": "g.dandre@company.biz" }
]
```

<CodeScript id="convert-users-to-email-string" script={[
  { command: "Select Word", line: 2, word: "name" },
  { command: "Command D", times: 2 },
  { command: "Right", times: 5 },
  { command: "Shift Command Left" },
  { command: "Backspace" },
  { command: "Type", text: "\"" },
  { command: "Select Word", line: 2, word: "email" },
  { command: "Command D", times: 2 },
  { command: "Right", times: 5 },
  { command: "Shift Option Left", times: 3 },
  { command: "Shift Left", times: 4 },
  { command: "Backspace" },
  { command: "Type", text: " <" },
  { command: "Command Right" },
  { command: "Shift Option Left" },
  { command: "Backspace", times: 3 },
  { command: "Type", text: ">\"," },
]} />


## Move object properties to a single line

Maybe you have a function call with some options that are taking up too much vertical space.

```javascript
// @script inline-object-properties
await animate({
  from: 0,
  to: 100,
  curve: "ease-in",
});
```

<CodeScript id="inline-object-properties" script={[
  { command: "Select Word", word: "  ", line: 2, msAfter: 700 },
  { command: "Command D", times: 2, msBetween: 150, msAfter: 500 },
  { command: "Backspace", times: 2, msBetween: 500, msAfter: 200 },
  { command: "Type", text: " " },
  { command: "Down", msAfter: 250 },
  { command: "Command Left" },
  { command: "Shift Up", msAfter: 200 },
  { command: "Shift Command Right" },
  { command: "Backspace", msAfter: 300 },
  { command: "Backspace", msAfter: 300 },
  { command: "Type", text: " " },
]} />

Even if you have a series of these, you can do them all at once:

```javascript
// @script inline-multiple-object-properties
await animate({
  from: 0,
  to: 100,
  curve: "ease-in",
});

await animate({
  delay: 500,
  from: 100,
  to: 50,
  curve: 'ease-out',
});
```

<CodeScript id="inline-multiple-object-properties" script={[
  { command: "Select Word", word: "  ", line: 2, msAfter: 700 },
  { command: "Command D", times: 2, msBetween: 150, msAfter: 300 },
  { command: "Command D", times: 4, msBetween: 150, msAfter: 500 },
  { command: "Backspace", times: 2, msBetween: 500, msAfter: 200 },
  { command: "Type", text: " " },
  { command: "Down", msAfter: 250 },
  { command: "Command Left" },
  { command: "Shift Up", msAfter: 200 },
  { command: "Shift Command Right", msAfter: 200 },
  { command: "Shift Left" },
  { command: "Backspace", msAfter: 300 },
  { command: "Type", text: " " },
  { command: "Command Left" },
]} />