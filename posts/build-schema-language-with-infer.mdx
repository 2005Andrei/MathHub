---
title: "Build your own schema language with TypeScript's infer keyword"
alt_title_1: "TypeScript's infer let me create my own language compiled"
alt_title_2: "Pushing the infer keyword to its limits"
alt_title_3: "How I Abused Template Literal Types to create a Schema Language in TypeScript"
description: "TODO"
---

A few years ago when I was learning Go, I learned about "Struct Tags".

```go
type Payload struct {
    Email string `json:"email,omitempty"`
}
```

Struct Tags allow you to attach "meta information" to fields. This can then be read by other parts of your program to modify its behavior.

In other languages that do not have this feature, metadata can be attached to fields by wrapping the field in some type.

```tsx
interface FieldWithMetadata<T> {
  field: T;
  metadata: string;
}
```

It's not as elegant, and requires boilerplate code.

Schema builders need to solve this problem. To create useful schemas you will want to add constraints to fields, such as requiring that an input string is a valid email address. Using Yup, a JavaScript schema builder, you might write code like this:

```tsx
import { object, string } from "yup";

const schema = object({
  email: string().email(),
});
```

This syntax is nice. However, there are some aspects of the syntax that are more verbose than I would like. To describe whether a field is required, we add `.required()`.

```tsx
const schema = object({
  email: string().email().required(),
});
```

To specify a default value, we add `.default()`.

```tsx
const schema = object({
  email: string().email().default("example.com"),
});
```

To describe a list of values, we wrap the type in `array()`.

```tsx
const schema = object({
  emails: array(string().email()).required(),
});
```

This is all fine, but I would love to be able to use a more terse syntax to describe the schema. I want to describe the optionality of a field in the same way as TypeScript does for interfaces:

```tsx
const schema = object({
  email?: string().email(),
});
```

Then, let's use the same syntax for default values as in JavaScript destructuring assignments:

```tsx
const schema = object({
  email?: string().email() = "example.com",
});
```

Then to top it off, let's add some custom syntax around constraints. I think `<>` looks nice:

```tsx
const schema = object({
  email?: string <email> = "example.com",
});
```

And if we were to accept a list of values, then I would like to be able to use a `[]` syntax like so:

```tsx
const schema = object({
  contacts: string[] <email>,
});
```

I like this, but it won't compile. This is just not valid JavaScript (or TypeScript) syntax.

But why should JavaScript limit what we can and cannot do? CSS-in-JS is a thing, and they use template literals to embed CSS in JavaScript.

```tsx
const Button = styled.button`
  display: inline-block;
  border-radius: 50%;
`;
```

Well, we can do the same thing.

```tsx
const schema = compileSchema(`{
  email?: string <email> = "example.com";
}`);
```

## Don't we lose all type information?

Right now, our schema builder's interface can be described like so.

```tsx
function compileSchema<T extends string>(template: T): Schema<???>;
```

We need to fill in the blanks. We somehow want to take the string template `T` and convert that to the type that it represents.

TypeScript has features that enable us to do that. Let's start off with the basics and build from there.


### Conditional types

The `extends` keyword enables conditional types in TypeScript.

```tsx
type Test<T> = T extends "yes" ? 0 : 1;

Test<"yes">; // 0
Test<"no">; // 1
```

We can use that to get the primitive represented by an input string:

```tsx
type ParsePrimitive<T> = T extends "string"
  ? string
  : T extends "number"
  ? number
  : T extends "boolean"
  ? boolean
  : never;

ParsePrimitive<"boolean">; // boolean
```

The repetitive `? : ? :` is somewhat unwieldy and hard to read, but it allows us to create a chain of conditionals.


### The `infer` keyword

The `ParsePrimitive` type is useful, but it's insufficient to tackle a more complex string such as `{value:number}`. We can't create an infinite number of cases to match every possible key-value combination.

To convert an object string `T` into a real type we need to

 1. parse that `T` represents an object,
 2. extract the key from `T`,
 3. extract the value from `T`,
 4. create an object using the key-value pair

TypeScript supports pattern matching for types. We can test whether `T` matches this object pattern using [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html).

```tsx
T extends `{${string}:${string}}`
```

With this we can create a conditional type that takes a potential object string `T` as input and returns some type when `T` matches the object pattern:

```tsx
type ParseObject<T> = T extends `{${string}:${string}}`
  ? some type
  : never;
```

But what do we return when `T` matches the object string pattern? We need access to the key and the value to be able to do anything useful.

The `infer` keyword allows us to create variables during pattern matching.

```tsx
type ParseObject<T> = T extends `{${infer K}:${infer V}}`
  ? // We have access to 'K' and 'V' here
  : never;
```

With access to `K` and `V`, we can create an object type.

```tsx
type ParseObject<T> = T extends `{${infer K}:${infer V}}`
  ? { [key in K]: ParsePrimitive<V> }
  : never;

ParseObject<`{value:number}`>; // { value: number }
```

This, on at least a basic level, demonstrates that we can convert strings to real types.

## Objects with multiple properties

The first hurdle we encounter are objects with multiple properties.

```tsx
ParseObject<`{a:string;b:number}`>; // { a: never }
```

A naive approach would be match create multiple conditionals for each number of properties:

```tsx
type ParseObject<T> =
  T extends `{${infer K0}:${infer V0}}`
  ? { [key in K0]: ParsePrimitive<V0> }
  : T extends `{${infer K0}:${infer V0};${infer K1}:${infer V1}}`
  ? { [key in K0]: ParsePrimitive<V0> } & { [key in K1]: ParsePrimitive<V1> }
  : T extends `{${infer K0}:${infer V0};${infer K1}:${infer V1}};${infer K2}:${infer V2}}`
  ? { [key in K0]: ParsePrimitive<V0> } & { [key in K1]: ParsePrimitive<V1> } & { [key in K2]: ParsePrimitive<V2> }
  : never;
```

This is obviously terrible and does not scale. We can divide and conquer instead.

Given that we have the content of an object string `T` that contains N properties, we can split the content of `T` into N many strings that contain one property. We can then parse each property string individually.

```tsx
type ParseObject<T> = T extends `{${infer Content}}`
  ? MergeArrayOfObjects<ParseProperties<SplitProperties<Content>>>
  : never;
```

Let's start off with `SplitProperties`.

### Split properties

Given a string `T`:

```tsx
`a:string;b:number;c:boolean`
```

We want the output of `SplitProperties<T>` to be:

```tsx
["a:string", "b:number", "c:boolean"];
```

We can somewhat trivially create a type that splits the string by `;`.

<StaticCodeBlock language="tsx" marginBottom={16}>
  {`\
type SplitProperties<T> = T extends \`\${infer A};\${infer B}\`
  ? [A, B]
  : [T];

Equals<
  SplitProperties<\`a:string;b:number;c:boolean\`>,
  ["a:string", "b:number;c:boolean"],
>;
`}
</StaticCodeBlock>

<SmallNote>`Equals` as used above asserts that the two arguments are equal.</SmallNote>

But this only splits at the first instance of `;`.

We can recursively split the latter part of the string until we reach the base case of a string that contains no `;`.

```tsx
type SplitProperties<T> = T extends `${infer A};${infer B}`
  ? [A, ...SplitProperties<B>]
  : [T];

Equals<
  SplitProperties<`a:string;b:number;c:boolean`>,
  ["a:string", "b:number", "c:boolean"],
>;
```

This is our first example of a recursive type. We're going to be using recursive types __a lot__ so make sure that you have a strong grasp of what is happening here.


### Parsing and merging the list of properties

Once we have the array (technically, tuple) of strings, we need to parse each element emitted by `SplitProperties<T>`.

```tsx
type ParseProperties<T extends string[]> = {
  [K in keyof T]: ParseProperty<T[K]>;
};
```

We'll implement `ParseProperty` later. For now we'll assume that `ParseProperty<T>` returns an object type that looks like so:

```tsx
{ [key in K]: V };
```

So for our example string, we have an output of:

```tsx
Equals<
  ParseProperties<SplitProperties<`a:string;b:number;c:boolean`>>,
  [{ a: string }, { b: number }, { c: boolean }],
>;
```

We can merge an array of objects like so:

```tsx
type MergeArrayOfObjects<T> = T extends [infer R, ...infer Rest]
  ? R & MergeArrayOfObjects<Rest>
  : {};

Equals<
  MergeArrayOfObjects<[{ a: string }, { b: number }, { c: boolean }]>,
  { a: string } & { b: number } & { c: boolean },
>;
```

It may seem overkill to create multiple types to do this. We could have split and parsed the input string in one pass.

```tsx
type ParsePropertyString<T extends string> =
  T extends `${infer R};${infer Rest}`
    ? ParseProperty<R> & ParsePropertyString<Rest>
    : ParseProperty<T>;

type T1 = Equals<
  ParsePropertyString<`a:string;b:number;c:boolean`>,
  { a: string } & { b: number } & { c: boolean }
>;
```

But shortening the code by merging responsibilities will lead to problem down the line when we start to deal with edge cases. I also believe that the code becomes much more readable and understandable with multiple types:

```tsx
type T1 = MergeArrayOfObjects<ParseProperties<SplitProperties<T>>>;

// vs

type T2 = ParsePropertyString<T>;
```

`T2` may be more terse, but its behavior feels much more opaque than `T1`.


## Object properties

A schema language that only supports primitives would produce large flat objects:

```tsx
const schema = schema(`{
  bookName: string;
  bookDescription: string;
  authorName: string;
  authorAge: number;
}`);
```

I would much rather write this as two object properties:

```tsx
const schema = schema(`{
  book: {
    name: string;
    description: string;
  };
  author: {
    name: string;
    age: number;
  };
}`);
```

In supporting object properties, we run into our first edge case.

```tsx
type SplitProperties<T> = T extends `${infer A};${infer B}`
  ? [A, ...SplitProperties<B>]
  : [T];

Equal<
  SplitProperties<`a:{b:string;c:number};d:boolean`>,
  ["a:{b:string", "c:number}", "d:boolean"],
>;
```

The pattern matching in `${infer A};${infer B}` is greedy, so it matches the first instance of `;` that it encounters. This splits object properties with multiple sub-properties.

We could try to amend this by splitting by objects before splitting by `;`.

```tsx
type SplitProperties<T> =
  T extends `${infer A}{${infer Content}};${infer B}`
  ? [`${A}{${Content}}`, ...SplitProperties<B>]
  : T extends `${infer A};${infer B}`
  ? [A, ...SplitProperties<B>]
  : [T];

Equals<
  SplitProperties<`a:{b:string;c:number};d:boolean`>,
  ["a:{b:string;c:number}", "d:boolean"],
>;
```

And, well, this seems to produce the correct result. However, this is easily broken by introducing one more level of nesting.

```tsx
Equals<
  SplitProperties<`a:{b:{c:string};d:number};e:boolean`>,
  ["a:{b:{c:string}", "d:number}", "e:boolean"],
>;
```

This just moves the problem one level down.

Additionally, specifically matching `;` after `{}` is a problem when the object is the last property.

```tsx                                
type SplitProperties<T> =
  T extends `${infer A}{${infer Content}};${infer B}`
  //                                     ^
  ? [`${A}{${Content}}`, ...SplitProperties<B>]
  : // ...;

type T1 = Equals<
  SplitProperties<`a:string;b:{c:number;d:boolean}`>,
  ["a:string", "b:{c:number", "d:boolean}"],
>
```

We need a more robust way to deal with object properties.


### Balancing brackets

The solutions we've used to split the list of properties all have the same problem. They split up object properties.

If we take a look at an incorrectly split up property, such as `a:{b:string` or `a:{b:{c:string}`, we can observe that the number of `{` and number of `}` are unequal. In a well formed object property, the number of `{` and `}` would always be equal.

This observation leads to a different solution. Instead of preventing object properties from being split in the first place, we can fix them after the fact by balancing brackets.

Balancing brackets can be done with a relatively simple loop, starting at the first element.

  1. If the number of `{` and the number of `}` in the current element are not equal, then the string is unbalanced.
  2. If the string is unbalanced, merge the current element with the next element and repeat step 1 again.
  3. If the string is balanced, move to the next element.

In JavaScript, this algorithm looks like so.

```tsx
function balanceBrackets(originalItems: string[]) {
  const items = [...originalItems];

  let i = 0;
  while (i < items.length - 1) {
    const s = items[i];
    if (numberOf("{").in(s) === numberOf("}").in(s)) {
      i++;
      continue;
    }

    items[i] = items[i] + items[i + 1];
    items.splice(i + 1, 1); // Removes element at i + 1
  }

  return items;
}
```

We can reduce an array of types into a single type using `infer` and recursive types. We observed this when implementing `MergeArrayOfObjects`.

```tsx
type MergeArrayOfObjects<T> = T extends [infer R, ...infer Rest]
  ? R & MergeArrayOfObjects<Rest>
  : {};
```

We can apply the same recursive pattern to balance brackets.

```tsx
type BalanceBrackets<T extends string[]> =
  T extends [
    infer Curr extends string,
    infer Next extends string,
    ...infer Rest extends string[]
  ]
    ? AreBracketsBalanced<Curr> extends true
      ? // Process next item
        [Curr, ...BalanceBrackets<[Next, ...Rest]>]
      : // Merge the next item with the current item
        // and recursively process the merged item
        BalanceBrackets<[`${Curr};${Next}`, ...Rest]>
    : T;
```

This implements the same algorithm as the JavaScript example above, just for types.

However, we need to define `AreBracketsBalanced`. We want that type to return `true` if the string `T` contains the same number of `{` and `}`, and false otherwise.

#### Counting number of characters in string type

To be able to check if a string contains an equal number of `{` and `}`, we first need to be able to count the number of those characters in the string.

We can access the number of elements in a tuple by reading its `length` property:

```tsx
[string, string, string]["length"]; // 3
```

However, TypeScript just returns `number` for the length of string constants.

```tsx
"abc"["length"]; // number
```

So what this problem boils down to is:

 1. converting an input string `T` into a tuple of characters
 2. filtering the tuple to only contain the character we're counting
 3. reading the `length` of the tuple

We can convert a string into a tuple by inferring one character at a time.

```tsx
type StringToTuple<T extends string> =
  T extends `${infer Char}${infer Rest}`
    ? [Char, ...StringToTuple<Rest>]
    : [];

StringToTuple<"abc">; // ["a", "b", "c"]
```

We can filter that tuple with some more recursive inference.

```tsx
type FilterTuple<T extends any[], U> =
  T extends [infer Item, ...infer Rest]
    ? Item extends U
      ? [Item, ...FilterTuple<Rest, U>]
      : FilterTuple<Rest, U>
    : [];

FilterTuple<[3, 2, 3, 3, 4, 5], 3>; // [3, 3, 3]
```

Combining these, we can count the instances of a character in a string.

```tsx
type InstancesInString<T extends string, Char> =
  FilterTuple<StringToTuple<T>, Char>["length"];

InstancesInString<`a:{b:{c:string}`, "{">; // 2
InstancesInString<`a:{b:{c:string}`, "}">; // 1
```

With that, we can create a type that checks whether the brackets are balanced.

```tsx
type AreBracketsBalanced<T extends string> =
  InstancesInString<T, "{"> extends InstancesInString<T, "}">
    ? true
    : false;

AreBracketsBalanced<`a:{b:{c:string}`>; // false
AreBracketsBalanced<`a:{b:{c:string}}`>; // true
```

Putting all of this together, we can now split properties correctly:

```tsx
type SplitProperties<T extends string> =
  BalanceBrackets<SplitString<T, ";">>;

Equals<
  SplitProperties<`a:{b:string;c:number};d:boolean`>,
  ["a:{b:string;c:number}", "d:boolean"],
>;
```


## Parsing a property

`SplitProperties` is now producing an array of strings representing properties for us to process. Let's now get implementing `ParseProperty`, which I promised earlier.

Currently, properties take the form of

 * a primitive property, such as `a:string`
 * an object property containing sub-properties, such as `a:{b:string}`

The commonality between these is that both start with a key and a colon, allowing us to create a common `KeyValue` type.

```tsx
type KeyValue<T extends string> = T extends `${infer K}:${infer V}`
  ? {
      key: K;
      value: ParseValue<V>;
    }
  : never;
```

When parsing the value, we can somewhat trivially distinguish between an object property and a primitive property.

```tsx
type ParseValue<T> = T extends `{${infer Content}}`
  ? ParseObject<`{${Content}}`>
  : ParsePrimitive<T>;
```

With these, we can create a `ParseProperty` type.

```tsx
type ParseProperty<T extends string> = KeyValue<T> extends {
  key: infer K extends string;
  value: infer V;
}
  ? { [key in K]: V }
  : never;
```

Putting this together, we have now implemented a somewhat basic parser.

```tsx
type ParseObject<T> = T extends `{${infer Content}}`
  ? MergeArrayOfObjects<ParseProperties<SplitProperties<Content>>>
  : never;

Equals<
  ParseObject<`{a:{b:string;c:number};d:boolean}`>,
  {
    a: { b: string; c: number };
    d: boolean;
  },
>
```


## Array properties

As mentioned earlier, I would like to support array properties using an array literal syntax.

```tsx
const schema = compileSchema(`{
  values: number[];
}`);
```

Arrays of objects should be supported, and arrays should be able to be multidimensional.

```tsx
const schema = compileSchema(`{
  matrix: { value: number }[][];
}`);
```

To support this, we can augment `FindValue` to check for array notation.

```tsx
type ParseValue<T> =
  // Match array notation
  T extends `${infer Before}[]`
  ? ParseValue<Before>[]
  :
  // Match object
  T extends `{${infer Content}}`
  ? ParseObject<`{${Content}}`>
  :
  // Default to primitives if neither array nor object
  ParsePrimitive<T>;

ParseValue<`{a:string[]}[][]`>; // { a: string[]; }[][]
```


## Optional values

I would like to be able to denote optional properties using `?:` like in TypeScript:

```tsx
const schema = compileSchema(`{
  value?: number;
}`);
```

We can update `KeyValue` to check for the presence of `?:`.

```tsx
type KeyValue<T extends string> = T extends `${infer K}?:${infer V}`
  ? {
      key: K;
      value: ParseValue<V> | null;
    }
  : T extends `${infer K}:${infer V}`
  ? {
      key: K;
      value: ParseValue<V>;
    }
  : never;

ParseValue<`{a?:number}`>; // { a: number | null }
```

This looks sensible, but there's a subtle bug.

If a non-optional object property contains an optional property, then the `?:` in `${infer K}?:${infer V}` matches the property inside of the object.

```tsx
type KeyValue<T extends string> = T extends `${infer K}?:${infer V}`
  ? [K, V]
  : // ...

KeyValue<`a:{b?:string}`>; // ["a:{b", "string}"]
```

We can resolve this by always matching the first `:` and then checking whether `K` ends with a `?`.

```tsx
type KeyValue<T extends string> = T extends `${infer K}:${infer V}`
  ? K extends `${infer KeyWithoutQuestionmark}?`
    ? {
        key: KeyWithoutQuestionmark;
        value: ParseValue<V> | null;
      }
    : {
        key: K;
        value: ParseValue<V>;
      }
  : never;
```


## Whitespace

You may have noticed the lack of whitespace in the examples above. However, that doesn't seem to square with how we intend for templates to be written by users.

```tsx
const schema = compileSchema(`{
  name: string;
  email: string;
}`);
```

TypeScript template literals are whitespace sensitive, which we can sidestep by stripping out all whitespace from the input string before processing it.

```tsx
type RemoveSpaces<T extends string> = T extends `${infer L} ${infer R}`
  ? RemoveSpaces<`${L}${R}`>
  : T;

type RemoveTabs<T extends string> = T extends `${infer L}\t${infer R}`
  ? RemoveTabs<`${L}${R}`>
  : T;

type RemoveNewlines<T extends string> = T extends `${infer L}\n${infer R}`
  ? RemoveNewlines<`${L}${R}`>
  : T;

type RemoveWhitespace<T extends string> =
  RemoveSpaces<RemoveTabs<RemoveNewlines<T>>>;

Equals<
  RemoveWhitespace<`{\n  hello: { world: string;\n}`>,
  `{hello:{world:string;}`,
>;
```

We can apply this by wrapping the input string to the top-level parsing type with `RemoveWhitespace`.

```tsx
type Parse<T extends string> = ParseObject<RemoveWhitespace<T>>;
```


## Take this further!

There is still lots left to design and implement:

 * Hash maps
 * Rules (such as `<email>`)
 * Default values
 * More custom data types
 * Syntax error handling (how do you show syntax errors to users?)
 * Add tests for the types
 * An actual runtime schema template parser and data validator

Feel free to take a look at the source code and take a stab at implementing some of the above